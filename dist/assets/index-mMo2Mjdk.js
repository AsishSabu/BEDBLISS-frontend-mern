import{s as ct,v as Dt,r as f,w as At,j as y,N as q,o as ut,U as oe,f as Ct}from"./index-KXlzdG9K.js";import{s as ie,a as ae}from"./hoist-non-react-statics.cjs-HqSw4Y_3.js";const bt=async()=>{try{return(await ae.get(`${oe}/profile`,{headers:{Authorization:`Bearer ${localStorage.getItem("access_token")}`}})).data.user.isBlocked}catch(t){throw console.error("Error fetching user profile:",t),t}},Ye=()=>{const{isAuthenticated:t,role:e}=ct(r=>r.userSlice),n=Dt(),[o,s]=f.useState(!1);return f.useEffect(()=>{bt().then(r=>{s(r)}).catch(r=>{console.error("Error checking user block status:",r),s(!0)})},[]),o?(n(At()),ie("Your account is blocked","error"),y.jsx(q,{to:"/auth/login",replace:!0})):t&&e==="user"?y.jsx(ut,{}):y.jsx(q,{to:"/auth/login",replace:!0})},Ge=()=>{const{role:t}=ct(s=>s.userSlice),e=Dt(),[n,o]=f.useState(!1);return f.useEffect(()=>{bt().then(s=>{o(s)}).catch(s=>{console.error("Error checking user block status:",s),o(!0)})},[]),n?(e(At()),y.jsx(q,{to:"/auth/login",replace:!0})):t!=="owner"?y.jsx(ut,{}):y.jsx(q,{to:"/owner",replace:!0})},Xe=()=>{const{isAuthenticated:t,role:e}=ct(r=>r.userSlice),n=Dt(),[o,s]=f.useState(!1);return f.useEffect(()=>{bt().then(r=>{s(r)}).catch(r=>{console.error("Error checking user block status:",r),s(!0)})},[]),o?(n(At()),y.jsx(q,{to:"/auth/login",replace:!0})):t&&e==="owner"?y.jsx(ut,{}):y.jsx(q,{to:"/auth/login",replace:!0})},Qe=()=>{const{isAuthenticated:t,role:e}=ct(n=>n.userSlice);return t&&e==="admin"?y.jsx(ut,{}):y.jsx(q,{to:"/admin/login",replace:!0})};var $t={exports:{}},zt={};/**
 * @license React
 * use-sync-external-store-shim.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var X=f;function ce(t,e){return t===e&&(t!==0||1/t===1/e)||t!==t&&e!==e}var ue=typeof Object.is=="function"?Object.is:ce,le=X.useState,fe=X.useEffect,de=X.useLayoutEffect,Ee=X.useDebugValue;function he(t,e){var n=e(),o=le({inst:{value:n,getSnapshot:e}}),s=o[0].inst,r=o[1];return de(function(){s.value=n,s.getSnapshot=e,ht(s)&&r({inst:s})},[t,n,e]),fe(function(){return ht(s)&&r({inst:s}),t(function(){ht(s)&&r({inst:s})})},[t]),Ee(n),n}function ht(t){var e=t.getSnapshot;t=t.value;try{var n=e();return!ue(t,n)}catch{return!0}}function Re(t,e){return e()}var pe=typeof window>"u"||typeof window.document>"u"||typeof window.document.createElement>"u"?Re:he;zt.useSyncExternalStore=X.useSyncExternalStore!==void 0?X.useSyncExternalStore:pe;$t.exports=zt;var Se=$t.exports;const k=()=>{},D=k(),Rt=Object,a=t=>t===D,N=t=>typeof t=="function",W=(t,e)=>({...t,...e}),ge=t=>N(t.then),it=new WeakMap;let me=0;const et=t=>{const e=typeof t,n=t&&t.constructor,o=n==Date;let s,r;if(Rt(t)===t&&!o&&n!=RegExp){if(s=it.get(t),s)return s;if(s=++me+"~",it.set(t,s),n==Array){for(s="@",r=0;r<t.length;r++)s+=et(t[r])+",";it.set(t,s)}if(n==Rt){s="#";const c=Rt.keys(t).sort();for(;!a(r=c.pop());)a(t[r])||(s+=r+":"+et(t[r])+",");it.set(t,s)}}else s=o?t.toJSON():e=="symbol"?t.toString():e=="string"?JSON.stringify(t):""+t;return s},U=new WeakMap,pt={},at={},Vt="undefined",lt=typeof window!=Vt,wt=typeof document!=Vt,we=()=>lt&&typeof window.requestAnimationFrame!=Vt,Jt=(t,e)=>{const n=U.get(t);return[()=>!a(e)&&t.get(e)||pt,o=>{if(!a(e)){const s=t.get(e);e in at||(at[e]=s),n[5](e,W(s,o),s||pt)}},n[6],()=>!a(e)&&e in at?at[e]:!a(e)&&t.get(e)||pt]};let _t=!0;const _e=()=>_t,[vt,Tt]=lt&&window.addEventListener?[window.addEventListener.bind(window),window.removeEventListener.bind(window)]:[k,k],ve=()=>{const t=wt&&document.visibilityState;return a(t)||t!=="hidden"},Te=t=>(wt&&document.addEventListener("visibilitychange",t),vt("focus",t),()=>{wt&&document.removeEventListener("visibilitychange",t),Tt("focus",t)}),Oe=t=>{const e=()=>{_t=!0,t()},n=()=>{_t=!1};return vt("online",e),vt("offline",n),()=>{Tt("online",e),Tt("offline",n)}},De={isOnline:_e,isVisible:ve},Ae={initFocus:Te,initReconnect:Oe},Mt=!Ct.useId,nt=!lt||"Deno"in window,Ce=t=>we()?window.requestAnimationFrame(t):setTimeout(t,1),St=nt?f.useEffect:f.useLayoutEffect,gt=typeof navigator<"u"&&navigator.connection,qt=!nt&&gt&&(["slow-2g","2g"].includes(gt.effectiveType)||gt.saveData),yt=t=>{if(N(t))try{t=t()}catch{t=""}const e=t;return t=typeof t=="string"?t:(Array.isArray(t)?t.length:t)?et(t):"",[t,e]};let be=0;const Ot=()=>++be,Kt=0,Yt=1,Gt=2,Ve=3;var tt={__proto__:null,ERROR_REVALIDATE_EVENT:Ve,FOCUS_EVENT:Kt,MUTATE_EVENT:Gt,RECONNECT_EVENT:Yt};async function Xt(...t){const[e,n,o,s]=t,r=W({populateCache:!0,throwOnError:!0},typeof s=="boolean"?{revalidate:s}:s||{});let c=r.populateCache;const R=r.rollbackOnError;let E=r.optimisticData;const b=T=>typeof R=="function"?R(T):R!==!1,w=r.throwOnError;if(N(n)){const T=n,p=[],I=e.keys();for(const g of I)!/^\$(inf|sub)\$/.test(g)&&T(e.get(g)._k)&&p.push(g);return Promise.all(p.map(S))}return S(n);async function S(T){const[p]=yt(T);if(!p)return;const[I,g]=Jt(e,p),[ft,i,st,Q]=U.get(e),j=()=>{const V=ft[p];return(N(r.revalidate)?r.revalidate(I().data,T):r.revalidate!==!1)&&(delete st[p],delete Q[p],V&&V[0])?V[0](Gt).then(()=>I().data):I().data};if(t.length<3)return j();let _=o,A;const H=Ot();i[p]=[H,0];const h=!a(E),B=I(),x=B.data,$=B._c,M=a($)?x:$;if(h&&(E=N(E)?E(M,x):E,g({data:E,_c:M})),N(_))try{_=_(M)}catch(V){A=V}if(_&&ge(_))if(_=await _.catch(V=>{A=V}),H!==i[p][0]){if(A)throw A;return _}else A&&h&&b(A)&&(c=!0,g({data:M,_c:D}));if(c&&!A)if(N(c)){const V=c(_,M);g({data:V,error:D,_c:D})}else g({data:_,error:D,_c:D});if(i[p][1]=Ot(),Promise.resolve(j()).then(()=>{g({_c:D})}),A){if(w)throw A;return}return _}}const Ht=(t,e)=>{for(const n in t)t[n][0]&&t[n][0](e)},ye=(t,e)=>{if(!U.has(t)){const n=W(Ae,e),o={},s=Xt.bind(D,t);let r=k;const c={},R=(w,S)=>{const T=c[w]||[];return c[w]=T,T.push(S),()=>T.splice(T.indexOf(S),1)},E=(w,S,T)=>{t.set(w,S);const p=c[w];if(p)for(const I of p)I(S,T)},b=()=>{if(!U.has(t)&&(U.set(t,[o,{},{},{},s,E,R]),!nt)){const w=n.initFocus(setTimeout.bind(D,Ht.bind(D,o,Kt))),S=n.initReconnect(setTimeout.bind(D,Ht.bind(D,o,Yt)));r=()=>{w&&w(),S&&S(),U.delete(t)}}};return b(),[t,s,b,r]}return[t,U.get(t)[4]]},Ie=(t,e,n,o,s)=>{const r=n.errorRetryCount,c=s.retryCount,R=~~((Math.random()+.5)*(1<<(c<8?c:8)))*n.errorRetryInterval;!a(r)&&c>r||setTimeout(o,R,s)},xe=(t,e)=>et(t)==et(e),[Qt,Le]=ye(new Map),Ne=W({onLoadingSlow:k,onSuccess:k,onError:k,onErrorRetry:Ie,onDiscarded:k,revalidateOnFocus:!0,revalidateOnReconnect:!0,revalidateIfStale:!0,shouldRetryOnError:!0,errorRetryInterval:qt?1e4:5e3,focusThrottleInterval:5*1e3,dedupingInterval:2*1e3,loadingTimeout:qt?5e3:3e3,compare:xe,isPaused:()=>!1,cache:Qt,mutate:Le,fallback:{}},De),Fe=(t,e)=>{const n=W(t,e);if(e){const{use:o,fallback:s}=t,{use:r,fallback:c}=e;o&&r&&(n.use=o.concat(r)),s&&c&&(n.fallback=W(s,c))}return n},Pe=f.createContext({}),Ue="$inf$",Zt=lt&&window.__SWR_DEVTOOLS_USE__,je=Zt?window.__SWR_DEVTOOLS_USE__:[],ke=()=>{Zt&&(window.__SWR_DEVTOOLS_REACT__=Ct)},We=t=>N(t[1])?[t[0],t[1],t[2]||{}]:[t[0],null,(t[1]===null?t[2]:t[1])||{}],Me=()=>W(Ne,f.useContext(Pe)),qe=t=>(e,n,o)=>t(e,n&&((...r)=>{const[c]=yt(e),[,,,R]=U.get(Qt);if(c.startsWith(Ue))return n(...r);const E=R[c];return a(E)?n(...r):(delete R[c],E)}),o),He=je.concat(qe),Be=t=>function(...n){const o=Me(),[s,r,c]=We(n),R=Fe(o,c);let E=t;const{use:b}=R,w=(b||[]).concat(He);for(let S=w.length;S--;)E=w[S](E);return E(s,r||R.fetcher||null,R)},$e=(t,e,n)=>{const o=e[t]||(e[t]=[]);return o.push(n),()=>{const s=o.indexOf(n);s>=0&&(o[s]=o[o.length-1],o.pop())}};ke();const Bt=Ct.use||(t=>{if(t.status==="pending")throw t;if(t.status==="fulfilled")return t.value;throw t.status==="rejected"?t.reason:(t.status="pending",t.then(e=>{t.status="fulfilled",t.value=e},e=>{t.status="rejected",t.reason=e}),t)}),mt={dedupe:!0},ze=(t,e,n)=>{const{cache:o,compare:s,suspense:r,fallbackData:c,revalidateOnMount:R,revalidateIfStale:E,refreshInterval:b,refreshWhenHidden:w,refreshWhenOffline:S,keepPreviousData:T}=n,[p,I,g,ft]=U.get(o),[i,st]=yt(t),Q=f.useRef(!1),j=f.useRef(!1),_=f.useRef(i),A=f.useRef(e),H=f.useRef(n),h=()=>H.current,B=()=>h().isVisible()&&h().isOnline(),[x,$,M,V]=Jt(o,i),z=f.useRef({}).current,te=a(c)?n.fallback[i]:c,It=(u,l)=>{for(const v in z){const d=v;if(d==="data"){if(!s(u[d],l[d])&&(!a(u[d])||!s(ot,l[d])))return!1}else if(l[d]!==u[d])return!1}return!0},xt=f.useMemo(()=>{const u=!i||!e?!1:a(R)?h().isPaused()||r?!1:a(E)?!0:E:R,l=O=>{const F=W(O);return delete F._k,u?{isValidating:!0,isLoading:!0,...F}:F},v=x(),d=V(),L=l(v),G=v===d?L:l(d);let m=L;return[()=>{const O=l(x());return It(O,m)?(m.data=O.data,m.isLoading=O.isLoading,m.isValidating=O.isValidating,m.error=O.error,m):(m=O,O)},()=>G]},[o,i]),J=Se.useSyncExternalStore(f.useCallback(u=>M(i,(l,v)=>{It(v,l)||u()}),[o,i]),xt[0],xt[1]),Lt=!Q.current,ee=p[i]&&p[i].length>0,K=J.data,Y=a(K)?te:K,rt=J.error,Nt=f.useRef(Y),ot=T?a(K)?Nt.current:K:Y,Ft=ee&&!a(rt)?!1:Lt&&!a(R)?R:h().isPaused()?!1:r?a(Y)?!1:E:a(Y)||E,Pt=!!(i&&e&&Lt&&Ft),ne=a(J.isValidating)?Pt:J.isValidating,se=a(J.isLoading)?Pt:J.isLoading,Z=f.useCallback(async u=>{const l=A.current;if(!i||!l||j.current||h().isPaused())return!1;let v,d,L=!0;const G=u||{},m=!g[i]||!G.dedupe,O=()=>Mt?!j.current&&i===_.current&&Q.current:i===_.current,F={isValidating:!1,isLoading:!1},jt=()=>{$(F)},kt=()=>{const C=g[i];C&&C[1]===d&&delete g[i]},Wt={isValidating:!0};a(x().data)&&(Wt.isLoading=!0);try{if(m&&($(Wt),n.loadingTimeout&&a(x().data)&&setTimeout(()=>{L&&O()&&h().onLoadingSlow(i,n)},n.loadingTimeout),g[i]=[l(st),Ot()]),[v,d]=g[i],v=await v,m&&setTimeout(kt,n.dedupingInterval),!g[i]||g[i][1]!==d)return m&&O()&&h().onDiscarded(i),!1;F.error=D;const C=I[i];if(!a(C)&&(d<=C[0]||d<=C[1]||C[1]===0))return jt(),m&&O()&&h().onDiscarded(i),!1;const P=x().data;F.data=s(P,v)?P:v,m&&O()&&h().onSuccess(v,i,n)}catch(C){kt();const P=h(),{shouldRetryOnError:dt}=P;P.isPaused()||(F.error=C,m&&O()&&(P.onError(C,i,P),(dt===!0||N(dt)&&dt(C))&&(!h().revalidateOnFocus||!h().revalidateOnReconnect||B())&&P.onErrorRetry(C,i,P,re=>{const Et=p[i];Et&&Et[0]&&Et[0](tt.ERROR_REVALIDATE_EVENT,re)},{retryCount:(G.retryCount||0)+1,dedupe:!0})))}return L=!1,jt(),!0},[i,o]),Ut=f.useCallback((...u)=>Xt(o,_.current,...u),[]);if(St(()=>{A.current=e,H.current=n,a(K)||(Nt.current=K)}),St(()=>{if(!i)return;const u=Z.bind(D,mt);let l=0;const d=$e(i,p,(L,G={})=>{if(L==tt.FOCUS_EVENT){const m=Date.now();h().revalidateOnFocus&&m>l&&B()&&(l=m+h().focusThrottleInterval,u())}else if(L==tt.RECONNECT_EVENT)h().revalidateOnReconnect&&B()&&u();else{if(L==tt.MUTATE_EVENT)return Z();if(L==tt.ERROR_REVALIDATE_EVENT)return Z(G)}});return j.current=!1,_.current=i,Q.current=!0,$({_k:st}),Ft&&(a(Y)||nt?u():Ce(u)),()=>{j.current=!0,d()}},[i]),St(()=>{let u;function l(){const d=N(b)?b(x().data):b;d&&u!==-1&&(u=setTimeout(v,d))}function v(){!x().error&&(w||h().isVisible())&&(S||h().isOnline())?Z(mt).then(l):l()}return l(),()=>{u&&(clearTimeout(u),u=-1)}},[b,w,S,i]),f.useDebugValue(ot),r&&a(Y)&&i){if(!Mt&&nt)throw new Error("Fallback data is required when using suspense in SSR.");A.current=e,H.current=n,j.current=!1;const u=ft[i];if(!a(u)){const l=Ut(u);Bt(l)}if(a(rt)){const l=Z(mt);a(ot)||(l.status="fulfilled",l.value=!0),Bt(l)}else throw rt}return{mutate:Ut,get data(){return z.data=!0,ot},get error(){return z.error=!0,rt},get isValidating(){return z.isValidating=!0,ne},get isLoading(){return z.isLoading=!0,se}}},Ze=Be(ze);export{Ge as P,Ye as a,Xe as b,Qe as c,Le as m,Ze as u};
